<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on ReDefense</title>
    <link>https://redefense.xyz/post/</link>
    <description>Recent content in Posts on ReDefense</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>© 2021–2022</copyright>
    <lastBuildDate>Tue, 07 Mar 2023 01:38:06 +0400</lastBuildDate><atom:link href="https://redefense.xyz/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Amsi First</title>
      <link>https://redefense.xyz/post/amsi-first/</link>
      <pubDate>Tue, 07 Mar 2023 01:38:06 +0400</pubDate>
      
      <guid>https://redefense.xyz/post/amsi-first/</guid>
      <description>AMSI In-Memory Patching / P/Invoke 
რომ დაგუგლოთ amsi bypass ან amsi evasion, უამრავ გამზადებულ “ქომანდებს” ნახავთ რომელთა ნახევარი უბრალოდ არ იმუშავებს. მიზეზი კი ის არის, რომ ანტივირუსი, რომელიც სისტემაზე არის მუდმივად განიცდის განახლებას და “მზა” ქომანდები სულაც არ არის ისეთ “მზამზარეული” როგორიც ერთი შეხედვით ჩანდა.
მაგალითად, ავიღოთ ეს ქომანდი, რომელიც 2016 წელს არის დაინტიფიცირებული:
[Ref].Assembly.GetType(&amp;#39;System.Management.Automation.AmsiUtils&amp;#39;).GetField(&amp;#39;amsiInitFailed&amp;#39;,&amp;#39;NonPublic,Static&amp;#39;).SetValue($null,$true) ამის მიზანი არის .NET reflection ტექნიკის დახმარებით მოახერხოს მემორიში amsiInitFailed ცვლადის შეცვლა, რის მერეც გაითიშება AMSI.</description>
    </item>
    
  </channel>
</rss>
